[{"grab":"**Hello world!!!**","views":"- `cargo new <project_name>` to create a new project with proper setup\n- `cargo build` to build the project and the run `./target/build/<build_name>` in thesame directory\n- `cargo run   ` to build and run the project\n- `cargo check ` check the validity of the code without building, see if it compiles without producing executable\n","tags":[]},{"grab":"`mut` and `let` --- > and shadowing","views":"to use thesame variable several time with diffferent type conversion from the previous type or reassined\n\n```rust\n\n//re-assigned\nlet x = 5;\nlet x = x +1\n\n// type conversion\nlet space = \"    \";\nlet space = space.len(); // callsed shadowing\n```\n\nbut same won't work for  type conversion\n\n```rust\n\nlet mut x = 5;\nx = x +1 // works\n\nlet space = \"    \";\nspace = space.len(); //output error\n```\n","tags":["rust"]},{"grab":"constant","views":"constant should not be return as function variable. need to be constantly defined for the compiler\n\n```rust\nconst THREE_DAYS: u32 = 24 * 3\n```","tags":["rust"]},{"grab":"loop keyword","views":"```rust\n\nloop {\n//expression\n//statement\n\nbreak variable // this returns the variable from the loop\n}\n```\n\nloop can be assigned\n\n```rust\nlet mut counter = 2;\nlet f = loop {\n    counter += 1;\n\n   if counter == 10 {\n    break counter * 2;\n    }\n\n}\n```\n\nmultiple loop can be stopped with label\n\n```rust\n'loop_label: loop {\n\n// inner loop \n   loop {\n     break 'loop_label;\n   }\n```","tags":[]},{"grab":"### Ownership\n\nDeals fully with data on the heap. like `String`","views":"e.g\n\n```rust\n\nlet s = String::from(\"hello\"); // ownership exist in throughout this scope\n\n{\n let g = String::from(\"hello1\"); // ownerhsip only exist in this scope\n}\n\nlet s1 = s;  //ownership now exist in s1 and s is discard\n\n//hence this should output error\n\nprintln!(\"print x: {}\", s); //output error s does not exist\n```\n\n`s1` takes ownership from `s`  i.e moved from `s` to `s1` because rust does shallow copy. and it is bad if memory is free twice and also having two variable pointing to thesame data on the heap. hence `s` needs to be invalid so we only have a single pointer and memory is freed once.\n\nto do deep copy manually we can use `clone`\n\n```rust\n\nlet s1 = String::from(\"hello\");\nlet s2 = s1.clone();\n\nprintln!(\"s1= {}, s2 = {}\", s1, s2);\n  ```\n\nalso when variable pointing to data on a heap is passed to a function, that function tkaes the ownership\n\n```rust\n\nlet s - String::from(\"hello\");\n\ntakes_ownership(s);\n\nprintln!(\"s: {}\", s); // should output error\n\n\nfn takes_ownership(s: String) {\nprintln!(\"s {}\", s);\n}\n```","tags":["rust"]},{"grab":"Referencing","views":"To prevent a function from taking over the ownership from outter scope\n\n```rust\n\nfn main() {\n\n  let mut s = String::from(\"hello\");\n\nchange(&mut s) //pass a reference to the function\n\n//s is still valid here\n\n}\n\n\nfn change(s: &mut String) {\n  s.push_str(\", world\");\n}\n```\n\n* One of the law of reference and borrowing is that you can't have more than one mutable reference\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;\n\n    println!(\"{}, {}\", r1, r2); //error\n    \n```\n\nYou can't have immutable reference and mutable reference.\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // no problem\n    let r2 = &s; // no problem\n    let r3 = &mut s; // BIG PROBLEM\n\n    println!(\"{}, {}, and {}\", r1, r2, r3);\n\n```\n\nsince at compile time, the last use of the muttable reference is tracked, you can make use of the mutable after the last use e.g\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // no problem\n    let r2 = &s; // no problem\n    println!(\"{} and {}\", r1, r2);\n    // variables r1 and r2 will not be used after this point\n\n    let r3 = &mut s; // no problem\n    println!(\"{}\", r3);\n\n\n```\n## Dangling reference\n\n``` rust\nfn dangling() -> &String {\n let s = String::from(\"hello\");\n\n&s\n}\n\n// this one will create a dangling pointer, since s will be out of scope once function is returned.\n```\n\nto prevent dangling reference\n\n```rust\n\nfn non_dangling() -> String {\n   let s = String::from(\"hello\");\n   s\n}\n```","tags":["rust"]},{"grab":"Slicing","views":"\n```rust\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!(\"the first word is: {}\", word);\n}\n\n```\nIndexing `s` with word won't be valid. `s` since s is already out of scope\n\n\nbut if we use slicing we can detect this error properly\n\n```rust\nfn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!(\"the first word is: {}\", word);\n}\n```\n\ndoing the println scope `word` is not valid cause the reference is conterminated; we have immutable and muttable reference from passing to function `first_word` and `clear`\n\nArray can also be sliced\n\n```rust\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\n\n```","tags":["rust"]}]