[{"grab":"**Hello world!!!**","views":"- `cargo new <project_name>` to create a new project with proper setup\n- `cargo build` to build the project and the run `./target/build/<build_name>` in thesame directory\n- `cargo run   ` to build and run the project\n- `cargo check ` check the validity of the code without building, see if it compiles without producing executable\n","tags":[]},{"grab":"`mut` and `let` --- > and shadowing","views":"to use thesame variable several time with diffferent type conversion from the previous type or reassined\n\n```rust\n\n//re-assigned\nlet x = 5;\nlet x = x +1\n\n// type conversion\nlet space = \"    \";\nlet space = space.len(); // callsed shadowing\n```\n\nbut same won't work for  type conversion\n\n```rust\n\nlet mut x = 5;\nx = x +1 // works\n\nlet space = \"    \";\nspace = space.len(); //output error\n```\n","tags":["rust"]},{"grab":"constant","views":"constant should not be return as function variable. need to be constantly defined for the compiler\n\n```rust\nconst THREE_DAYS: u32 = 24 * 3\n```","tags":["rust"]},{"grab":"loop keyword","views":"```rust\n\nloop {\n//expression\n//statement\n\nbreak variable // this returns the variable from the loop\n}\n```\n\nloop can be assigned\n\n```rust\nlet mut counter = 2;\nlet f = loop {\n    counter += 1;\n\n   if counter == 10 {\n    break counter * 2;\n    }\n\n}\n```\n\nmultiple loop can be stopped with label\n\n```rust\n'loop_label: loop {\n\n// inner loop \n   loop {\n     break 'loop_label;\n   }\n```","tags":[]},{"grab":"### Ownership\n\nDeals fully with data on the heap. like `String`","views":"e.g\n\n```rust\n\nlet s = String::from(\"hello\"); // ownership exist in throughout this scope\n\n{\n let g = String::from(\"hello1\"); // ownerhsip only exist in this scope\n}\n\nlet s1 = s;  //ownership now exist in s1 and s is discard\n\n//hence this should output error\n\nprintln!(\"print x: {}\", s); //output error s does not exist\n```\n\n`s1` takes ownership from `s`  i.e moved from `s` to `s1` because rust does shallow copy. and it is bad if memory is free twice and also having two variable pointing to thesame data on the heap. hence `s` needs to be invalid so we only have a single pointer and memory is freed once.\n\nto do deep copy manually we can use `clone`\n\n```rust\n\nlet s1 = String::from(\"hello\");\nlet s2 = s1.clone();\n\nprintln!(\"s1= {}, s2 = {}\", s1, s2);\n  ```\n\nalso when variable pointing to data on a heap is passed to a function, that function tkaes the ownership\n\n```rust\n\nlet s - String::from(\"hello\");\n\ntakes_ownership(s);\n\nprintln!(\"s: {}\", s); // should output error\n\n\nfn takes_ownership(s: String) {\nprintln!(\"s {}\", s);\n}\n```","tags":["rust"]},{"grab":"Referencing","views":"To prevent a function from taking over the ownership from outter scope\n\n```rust\n\nfn main() {\n\n  let mut s = String::from(\"hello\");\n\nchange(&mut s) //pass a reference to the function\n\n//s is still valid here\n\n}\n\n\nfn change(s: &mut String) {\n  s.push_str(\", world\");\n}\n```\n\n* One of the law of reference and borrowing is that you can't have more than one mutable reference\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &mut s;\n    let r2 = &mut s;\n\n    println!(\"{}, {}\", r1, r2); //error\n    \n```\n\nYou can't have immutable reference and mutable reference.\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // no problem\n    let r2 = &s; // no problem\n    let r3 = &mut s; // BIG PROBLEM\n\n    println!(\"{}, {}, and {}\", r1, r2, r3);\n\n```\n\nsince at compile time, the last use of the muttable reference is tracked, you can make use of the mutable after the last use e.g\n\n```rust\n    let mut s = String::from(\"hello\");\n\n    let r1 = &s; // no problem\n    let r2 = &s; // no problem\n    println!(\"{} and {}\", r1, r2);\n    // variables r1 and r2 will not be used after this point\n\n    let r3 = &mut s; // no problem\n    println!(\"{}\", r3);\n\n\n```\n## Dangling reference\n\n``` rust\nfn dangling() -> &String {\n let s = String::from(\"hello\");\n\n&s\n}\n\n// this one will create a dangling pointer, since s will be out of scope once function is returned.\n```\n\nto prevent dangling reference\n\n```rust\n\nfn non_dangling() -> String {\n   let s = String::from(\"hello\");\n   s\n}\n```","tags":["rust"]},{"grab":"Slicing","views":"\n```rust\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!(\"the first word is: {}\", word);\n}\n\n```\nIndexing `s` with word won't be valid. `s` since s is already out of scope\n\n\nbut if we use slicing we can detect this error properly\n\n```rust\nfn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!(\"the first word is: {}\", word);\n}\n```\n\ndoing the println scope `word` is not valid cause the reference is conterminated; we have immutable and muttable reference from passing to function `first_word` and `clear`\n\nArray can also be sliced\n\n```rust\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\n\n```","tags":["rust"]},{"grab":"## struc","views":"```rust\n struct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n \n```\n used\n```rust\n fn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n} \n```\n moved user1 to user2\n\n```rust\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n}\n```\n\n## struct tuple\n\n```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n```\n","tags":[]},{"grab":"printing Struct","views":"```rust\n\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {:?}\", rect1);\n}\n\n```\n\ncan also make use of `dbg!` macro use that it takes ownership comparaed to `println!` that takes reference\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&rect1);\n}\n```\n\noutput\n\n```\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n     Running `target/debug/rectangles`\n[src/main.rs:10] 30 * scale = 60\n[src/main.rs:14] &rect1 = Rectangle {\n    width: 60,\n    height: 50,\n}\n```\n","tags":[]},{"grab":"### Method syntax","views":"```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n\n   fn width(&self) -> bool {\n        self.width > 0\n    }\n\n    fn can_hold(&self, other: &Rectangle) -> bool {\n        self.width > other.width && self.height > other.height\n    }\n\n\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n```\n\n\nfunction created under `impl` are called Associated function and there are some that doesn't take the reference `&self` but return self\n\n```rust\nimpl Rectangle {\n    fn square(size: u32) -> Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n\n```\n\nthey are often call like this `Rectangle::square(3)`\n","tags":[]},{"grab":"enum","views":"```rust\n\nenum IpAddrKind {\n      V4,\n       V6,\n}\n\nlet four = IpAddrKind::V4;\nlet six = IpAddrKind::V6;\n```\n\nenum values\n\n```rust\n    enum IpAddr {\n        V4(String),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(String::from(\"127.0.0.1\"));\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n\n```\n\n\nother enum definition\n```rust\n\nenum IpAddr {\n        V4(u8, u8, u8, u8),\n        V6(String),\n }\n\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\n```\n\nRust finds a way around not using null via `Option`\n\n```rust\nenum Option<T> {\n    None,\n    Some(T),\n}\n```\n\n\ne.g if a  function or value will either be e.g `String | null` you can use `Option<String>` which means the value is either `Some(string) | None`","tags":["rust"]},{"grab":"`match` control flow","views":"works commonly with enum and state variables\n\n```rust\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n\n```\n\n```rust\n#[derive(Debug)] // so we can inspect the state in a minute\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(state) => {\n            println!(\"State quarter from {:?}!\", state);\n            25\n        }\n    }\n}\n\n```\n\n\nusing `Opton<T>`\n\n```rust\n    fn plus_one(x: Option<i32>) -> Option<i32> {\n        match x {\n            None => None,\n            Some(i) => Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n\n\n```\n\ndefault match\n\n```rust\n\n    let dice_roll = 9;\n    match dice_roll {\n        3 => add_fancy_hat(),\n        7 => remove_fancy_hat(),\n        _ => (),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n\n```\n","tags":["rust"]},{"grab":"if-let","views":"can be use in replace of match with trade off od exhuastive matching list\n\ne.g\n\n```rust\n    let mut count = 0;\n    match coin {\n        Coin::Quarter(state) => println!(\"State quarter from {:?}!\", state),\n        _ => count += 1,\n    }\n\n    let mut count = 0;\n    if let Coin::Quarter(state) = coin {\n        println!(\"State quarter from {:?}!\", state);\n    } else {\n        count += 1;\n    }\n\n\n```","tags":[]},{"grab":"## Crates","views":"Two type of crates:\n\n* Binary - src/main.rs\n* Library crate = src/lib.rs\n\nmost times crate just means library crates\n\na package might contain both binary and library crate","tags":[]},{"grab":"Modules to control scopt and privacy\n\n* from crate root: src/main.rs or `src/lib.rs`\n* Declaring module.  `mod garden` compiler look through `src/garden.rs` or `src/garden/mod.rs`\n* sub-module: `mod vegetable` the compiler looks for it through `src/garden/vegetables.rs` or `src/garden/vegetables/mod.rs`\n* Path code in module: mod can be refer from anywhere in the crate e.g `crate::garden::vegetables::Aspargus`\n* Private and public: all modules are private by default within the parent module. use `pub mod` instead of `mod` to make them public\n* `use` keyword to make Namespace available within scope `use crate::garden::vegetables::Asparagus;` then we can just call `Asparagus` ","views":"```\nbackyard\n├── Cargo.lock\n├── Cargo.toml\n└── src\n    ├── garden\n    │   └── vegetables.rs\n    ├── garden.rs\n    └── main.rs\n\n```\n\nsrc/main.rs\n\n```rust\nuse crate::garden::vegetables::Asparagus;\n\npub mod garden; //include code found in src/garden.rs\n\nfn main() {\n    let plant = Asparagus {};\n    println!(\"I'm growing {:?}!\", plant);\n}\n\n```\n\nsrc/garden.rs\n\n```rust\n\npub mod vegetables;\n\n```\n\nsrc/garden/vegetables.rs\n\n```rust\n#[derive(Debug)]\npub struct Asparagus {}\n```\n\n## Grouping related code in modules\n\n```rust\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n```\n\nlooks like file structure\n\n```\ncrate\n └── front_of_house\n     ├── hosting\n     │   ├── add_to_waitlist\n     │   └── seat_at_table\n     └── serving\n         ├── take_order\n         ├── serve_order\n         └── take_payment\n\n```","tags":[]},{"grab":"### Path referencing to an item in the module tree\n","views":"```rust\n\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n```\n\nAbosule path good for when the module might not have same parent `front_of_house` can be moved to another file. \n\nRelative path: if the co-exist in same file or mod.\n\n### starting relative path with `super`\n\n```rust\n\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::deliver_order(); // act like absolute path\n    }\n\n    fn cook_order() {}\n}\n```\n\n\nstruct by default are private including it fields\n\n```rust\nmod back_of_house {\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &str) -> Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Order a breakfast in the summer with Rye toast\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    // Change our mind about what bread we'd like\n    meal.toast = String::from(\"Wheat\");\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    // The next line won't compile if we uncomment it; we're not allowed\n    // to see or modify the seasonal fruit that comes with the meal\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n\n```\n\nwhy enum be default are public","tags":["rust"]},{"grab":"### Bringing path into scope with the `use` keyword","views":"```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\nor you can\n\n```rust\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n}\n\n```\n\n\nwont work when called directlyt inside a module\n\n```rust\n\nuse crate::front_of_house::hosting;\n\nmod customer {\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n\n//either you call it like this\n\nmod customer {\nuse crate::front_of_house::hosting;\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n\n// or like this\n\nuse crate::front_of_house::hosting;\nmod customer {\n    pub fn eat_at_restaurant() {\n        super::hosting::add_to_waitlist();\n    }\n}\n\n```\n\nif the import contain thesame method name like\n\n```rust\nuse std::fmt;\nuse std::io;\n\nfn function1() -> fmt::Result {\n    // --snip--\n}\n\nfn function2() -> io::Result<()> {\n    // --snip--\n}\n\n```\n\n\n### Aliasing with `as`\n\n```rust\n\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -> Result {\n    // --snip--\n}\n\nfn function2() -> IoResult<()> {\n    // --snip--\n}\n```\n\n### Re-exporting name with  `pub use`\n\n```rust\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\n### Using External Packages\n\nadd to dependency in `Cargo.toml`\n\n```toml\nrand = \"0.8.5\"\n```\n\nimport and use\n\n```rust\nuse rand::Rng;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n}\n```\n\n### using nested paths to clean up large `use` lists\n\n```rust\nuse std::cmp::Ordering;\nuse std::io;\n```\n\ncan be clean up with\n\n```rust\nuse std::{cmp::Ordering, io};\n```\n\nalso this:\n\n```rust\nuse std::io;\nuse std::io::Write;\n\n```\n\ncan be clean up with\n\n```rust\nuse std::io::{Self, Write};\n```\n\n## The Glob Operator\n\n```rust\nuse std::collections::*;\n\n```","tags":[]},{"grab":"### separate module into different files\n","views":"src/lib.rs\n\n```rust\n\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n```\n\nsrc/front_of_house : *same name has the module*\n\n```rust\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n\n```\n\nwe can go further and separate hosting into his own file\n\nsrc/front_of_house\n\n```rust\npub mod hosting\n```\n\nsrc/front_of_house/hosting.rs\n\n```rust\npub fn add_to_waitlist() {}\n\n```","tags":["rust"]},{"grab":"## vector","views":"```rust\n\n    let v: Vec<i32> = Vec::new(); //empty vector\n\n    let v = vec![1, 2, 3]; //default type is i32\n\n```\n\nupdating\n\n```rust\n\n\nlet mut v = Vec::new();\n\nv.push(5);\nv.push(6);\nv.push(7);\nv.push(8);\n```\n\nReading element:\n\n```rust\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &i32 = &v[2];\n    println!(\"The third element is {third}\");\n\n    let third: Option<&i32> = v.get(2);\n    match third {\n        Some(third) => println!(\"The third element is {third}\"),\n        None => println!(\"There is no third element.\"),\n    }\n\n```\n\nusing `&v[100]` out of index causes a panic and `.get(100)` does not since its using `Option<T>`\n\nalso ownership occurs e.g\n\n```rust\nfn main() {\n    let mut v = vec![1, 2, 3, 4, 5];\n\n    let first = &v[0];// immutable\n\n    v.push(6); //mutable\n\n    println!(\"The first element is: {first}\");\n}\n\n```\n\n`v.push` might cause a change to the memory layout, better its called before the assignment to `first`\n\nLoop through vector\n\n\n```rust\n    let mut v = vec![100, 32, 57];\n    for i in &mut v {\n        *i += 50;\n    }\n\n```\n\nStoring multiple type\n\n```rust\n    enum SpreadsheetCell {\n        Int(i32),\n        Float(f64),\n        Text(String),\n    }\n\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n\n\n```\n","tags":[]},{"grab":"## String\n\n","views":"\nwe have string literal and string object\n```rust\n\n    let mut s1 = String::from(\"foo\");\n    let s2 = \"bar\";\n    s1.push_str(s2); // push_str does not take ownership\n    println!(\"s2 is {s2}\");\n\n\n```\n\nRust does not allow indexing into string due to how string might be layed out. some string unicode can have more than 1 byte repesentation. hence it prefers slicing\n\n```rust\nlet hello = \"hello\";\nlet s = &hello[..1]; // h\n```\n\nbut this for example\n\n```rust\n\nlet hello = \"Здравствуйте\";\n\nlet s = &hello[0..4]; // Зд\n\n```\n\nlooping through string\n\n```rust\n\nlet hello = \"Здравствуйте\";\nfor b in hello.bytes() {\n    println!(\"{b}\");\n}\n\nfor b in hello.chars() {\n    println!(\"{b}\");\n}\n\n\n\n```","tags":["rust"]},{"grab":"### HashMap","views":"```rust\n\nuse std::collections::HashMap;\n\nlet myt scores = HashMap::new();\n\nscores.insert(String::from(\"Blue\"), 10);\n\nlet team_name = String::from(\"Blue\");\nlet score = scores.get(&team_name).copied().unwrap_or(0);\n```\n\nthe `.copied` returns `Option<T>` and if `None` is returned the `.unwrap_or(0)` returns a default value `0`\n\n### Hashmap ownership\n\n```rust\n\nlet field_name = String::from(\"favorite\");\n\nlet fiels_value = String::from(\"Blue\");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n\n// field_name and field_value won't be valid here has insert takes ownership, this wont occur if we pass in a reference\n```\n\nAdding a key and value if a key isn't prresent\n\n```rust\n\nfn main() {\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n    scores.insert(String::from(\"Blue\"), 10);\n\n    scores.entry(String::from(\"Yellow\")).or_insert(50);\n    scores.entry(String::from(\"Blue\")).or_insert(50);\n\n    println!(\"{:?}\", scores);\n}\n\n\n\n```\n\nthe `or_insert` check if a value exist if not insert this value and it also return a mutable reference of the  Hashmap variable.\n\nLoop\n\n```rust\n    for (key, value) in &scores {\n        println!(\"{key}: {value}\");\n    }\n```\n\nupdating value based on old value\n\n```rust\n    use std::collections::HashMap;\n\n    let text = \"hello world wonderful world\";\n\n    let mut map = HashMap::new();\n\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(\"{:?}\", map);\n\n```\n\nthis works because  `count` points to `&mut map` and to update it we deference it using `*` hence `*count+=1`\n\n\n","tags":["rust"]},{"grab":"### Panic Mode","views":"abort on panic\n\n```\n\n[profile.release]\npanic = 'abort'\n```\n\n```rust\nfn main(){\n    panic!(\"crash\";\n ```\n\nthis should cause a panic\n\n```rust\n\nlet v = vec![1, 2, 3]\nv[99] //causes panic","tags":["rust"]},{"grab":"## Recoverable error Result","views":"```rust\n enum Result<T, E> {\n    Ok(T),\n    Err(E),\n}\n \n```\n opening a file returns result\n\n`let greeting_file_result = File::open(\"hello.txt\");`\n\n```rust\n use std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => panic!(\"Problem opening the file: {:?}\", error),\n    };\n} \n```\n \nMatching different errors: file errrors can be of different kind either notfound or other kind of error\n\n```rust\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) => file,\n        Err(error) => match error.kind() {\n            ErrorKind::NotFound => match File::create(\"hello.txt\") {\n                Ok(fc) => fc,\n                Err(e) => panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error => {\n                panic!(\"Problem opening the file: {:?}\", other_error);\n            }\n        },\n    };\n}\n\n```\n\n### shortcut to Panic: `unwrap` and `expect`\n\n```rust\n\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap();\n}\n```\nunwrap returns panic result Err if any error and OK file if found\n\nwith `expect` you can customize your own panic error\n\n```rust\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")\n        .expect(\"hello.txt should be included in this project\");\n}\n```\n\n### Propagating error\n\nReturning error of the failing code from a function\n\n```rust\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let username_file_result = File::open(\"hello.txt\");\n\n    let mut username_file = match username_file_result {\n        Ok(file) => file,\n        Err(e) => return Err(e),\n    };\n\n    let mut username = String::new();\n\n    match username_file.read_to_string(&mut username) {\n        Ok(_) => Ok(username),\n        Err(e) => Err(e),\n    }\n}\n\n```\n\nshort cut to write this\n\n```rust\n\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -> Result<String, io::Error> {\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    username_file.read_to_string(&mut username)?;\n    Ok(username)\n}\n```\nthe `?` reutrns OK to the variable assigned to and if err it taps out fo the function and the function `read_username_from_file` for example will return and Error.\n\ncalling this in `main()` won't work.\n\n\n```rust\n use std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n} \n```\n will need to change the return type of `main` from `()` to Result\n\n```rust\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let greeting_file = File::open(\"hello.txt\")?;\n\n    Ok(())\n}\n```\n","tags":[]},{"grab":"### Generic Data Types","views":"```rust\n\nfn largest<T>(list: &[T]) -> &T { }\n```\n\nstruct with multiple type fields\n\n```rust\n\nstruct Point<T, U> {\n\n    x: T,\n    y: U,\n}\n\nimpl<T, U> Point<T, U> {\n    fn x(&self) -> &T {\n        &self.x\n    }\n}\n\nenum Result<T, E> {\n    OK(T),\n    Err(E),\n}\n```\n\nspecify a type should only have this function\n\n```rust\nimpl Point<f32> {\n    fn distance_from_origin(&self) -> f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\n```\n\n","tags":["rust"]},{"grab":"### Trait\n\n","views":"definition\n\n```rust\n\npub trait Summary {\n        fn summarize(&self) -> String;\n}\n\n// the method can be defined has default definition for implementation\n\npub trait Summary {\n    fn summarize(&self) -> String {\n       String::from(\"(Read more...)\")\n}\n\n```\n\nother object can inherit from it\n\n```rust\n\npub struct TraitInherit {\n    pub field1: String,\n    pub field2: String\n}\n\nimpl Summary for TraitInherit {\nfn summarize(&self) -> String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n```\n\nonce it is inherited you can use it like\n\n```rust\nfn main() {\nlet tt = TraitInherit {\n    field1: String::from(\"hello\"),\n    field2: String::from(\"world\")\n}\nprintln!(\"trait: {}\", tt.summarize());\n```\n\ntrait  has parameter\n\n```rust\n\npub fn notify(item: &impl Summary) {\n......\n}\n```\n\nTrait has bound\n\n```rust\n\npub fn notify<T: Summary>(item: &T) {\nprintln!(\"{}\", item.summarize());\n}\n```\n\nmultiple bound\n\n```rust\npub fn notify<T: Summary>(item: &T, item2: &T) {\nprintln!(\"{}\", item.summarize());\n}\n\npub fn notify(item1: &impl Summary, item2: &impl Summary) {\n```\n\nSpecify multiple trait bound with `+`\n\n```rust\npub fn notify(item: &(impl Summary + Display)) {}\n\npub fn notify<T: Summary + Display>(item: &T) {}\n```\n\nclearer trait with `where` clauses\n\ninstead of this\n\n```rust\nfn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {\n```\n\nyou can do this\n\n```rust\nfn some_function<T, U>(t: &T, u: &U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{}\n```\n\nReturning type with Trait\n\n```rust\n\nfn returns_summarizable() -> impl Summary {\n    TraitInherit { }\n}\n```\n\ncan't use trait return if return contains more than two type e.g `if true TraitInherit1 else Traitinherit2`\n\n###  using trait bound to conditionally implement a method\n\n```rust\n\nuse std::fmt::Display;\n\nstruct Pair<T> {\n    x: T,\n    y: T,\n}\n\n//all type have this fn in Pair\nimpl<T> Pair<T> {\n    pub fn new(x: T, y:T) -> self {\n    Self {x, y}\n}\n\n//while that that has Display owns this\n\nimpl<T:Display + PartialOrd> Pair<T> { \n    fn cmp_display(&self) {}\n}\n```\n\n\n\n","tags":[]},{"grab":"## Reference with lifetime\n\nprevent dangling reference","views":"```rust\n fn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {}\", result);\n}\n\nfn longest(x: &str, y: &str) -> &str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n} \n```\n this returns error since rust does not know which of the type to return and its not generic\n\n```rust\n\nfn longest<'a>(x: &'a str, y: &'a str) -> &'a str {\n    if x.len() > y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"long string is long\");\n\n    {\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    }\n}\n```\n\nthis won't throw any error cause the liftetime always last wrt to the shortes lifetime\n\nbut if we defined it like this we will recieve error\n\n```rust\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}\n\n```\n\nthis will show error because string2 will caused a dangling reference if returned from longest since string2 will be out of scope later\n\nif we have\n\n```rust\nfn longest<'a>(x: &'a str, y: &str) -> &'a str {\n    x\n}\n```\n\nwe won't have previous error with the inner scope\n\nStruct with liftetime annotation\n\n```rust\nstruct ImportantExcerpt<'a> {\n    part: &'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n\n```\n\nno error because novel still have a long lifteime.\n\nLifetime Elision\n\n```rust\n\nfn first_word(s: &str) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n```\nreason while this work is if you have one input type of same return type with the function, the compiler sees it like this\n\n```rust\nfn first_word<'a>(s: &'a str) -> &'a str {\n```\n\nLifetime annotations in Method Definitions\n\n```rust\n\nimpl<'a> ImportantExcerpt<'a> {\n    fn announce_and_return_part(&self, announcement: &str) -> &str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n```\n\nthis automatocally assign `Self` to the  return type\n\nThe static Lifetime\n\nlifetime that can last through out the entire program\n\n```rust\n let s: &'static str = \"I have a static lifetime.\"; \n```\n \n","tags":[]},{"grab":"## How to write Tests","views":"```rust\n\n#[cfg(test)]\nmod tests {\n    \nuse supper::* // to import all mod\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n\n    #[test]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n\n    //custom failure\n    #[test]\n    fn custom() {\n        let result = function(\"Carol\");   \n        assert!(result.contains(\"Carol\"),\n            \"Greeting did not contain name, value was `{}`\",\n            result\n           );\n    }\n    \n    #[test]\n    #[should_panic] // if pannic test pass if not test fails\n    fn panicc() {\n        Guess:new(200)\n    }\n\n    //be sure the panic is the right panic\n    #[test]\n    #[shoul_panic(expected = \"comment here\")]\n    fn panicc() {\n        Guess::new(200);\n    }\n    \n// incase you don't want the test to panic but returns error for any failed assetion inside\n\n    #[test]\n    fn np_pannic() -> Result<(), String> {\n        if 2 +2 ==4 {\n            OK(())\n       } else {\n            Err()\n        }\n    }\n}\n```\n\n","tags":[]},{"grab":"## How to run test","views":"rust use parrallism by defualt you can set it to use 1 thread\n\n```sh\ncargo test -- --test-threads=1\n```\n\nmake it show you println! output for passed test\n\n```sh\n$ cargo test -- --show-output\n```\n\nyou can run a single test\n\n```sh\ncargo test <test_name>\n```\n\nfilter test to run all test having suffix add\n\n```sh\ncargo test add \n```\nignore a test\n\n```rust\n\n#[test]\n#[ignore]\nfn test_name(){}\n```\n\nand you can later decide to run the ignore test\n\n```sh\ncargo test -- --ignored\n```\n\n\n","tags":[]}]