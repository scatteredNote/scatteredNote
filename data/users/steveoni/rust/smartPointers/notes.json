[{"grab":"## Box<T>\n\nuseful for when\n\n* you have type whose size can't be know at compiler time\n* you want to own a value and care only it is a type that implements a particular trait\n* you have large amount of data you want to transfer ownership without copying the data","views":"## Infinit Recursive example\n\nwe have\n\n```rust\n enum List {\n    Cons(132, List),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n```\n\nthis will output error, reason be that rust try to define the size of List, the size of enum is the size of the largest variant.\nso Con point to 132 + List has the size, and List point to cons and cons point to list which is infinity\n\n![](https://doc.rust-lang.org/book/img/trpl15-01.svg)\n\nInstead we can use `Box<T>`\n\n```rust\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n\n```\n\nBox<List> is a pointer to List , and pointer do have a fixed size.\n\n\nBox implement `Deref` trait which makes it usable has a reference and also `Drop` trait make it get cleanup whenever its out of scope.","tags":[]},{"grab":"# Treating smart pointers as regular reference","views":"using the Box smart pointer\n\n```rust\nlet y = 5;\nlet x = Box::new(x);\n\nassert_eq!(5, y);\nassert_eq!(5, *x);\n```\n\nthis works perfectly but if we use cutom struct it won't work well\n\n```rust\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n   fn new(x: T) -> MyBox<T> {\n       MyBox(x);\n    }\n}\n\nfn main() {\n  let x = 5;\n  let y = MyBox::new(x);\n  \n  assert_eq!(5, x);\n  assert_eq!(5, *y);\n```\n\nthis will give error, hence we need to inherit the `Deref` trait\n\n```rust\nuse std::ops::Deref;\nstruct MyBox<T>(T);\n\nimpl<T> Deref for MyBox<T> {\n\n   type Target = T;\n\n\n   fn new(x: T) -> MyBox<T> {\n       MyBox(x);\n    }\n\n    fn deref(&self) -> &self::Target {\n    &self.0 //point to the first element has reference\n}\n\n```\n\nso behind the scene when `*y` its called Rust run this `*(y.deref())`\n\nThere also exist `DerefMut` for mutable reference","tags":[]}]