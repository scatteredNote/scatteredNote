[{"grab":"### closures","views":"Closures genrally mean capturing the variables in outer enviroment into inner enviroment\n\nrust have something similar to annonymous function\n\n```rust\n\nlet g = |x| x;\n\ng(String::from(\"hello\");\n```\n\nit can also takes defined type\n\n```rust\n\nlet g = |x: i32| -> i32 { x}\n\ng(10);\n```\n\nif type is not defined the compiler infer the type from the first call\n\n```rust\nlet g = |x| { println!(\"{x}\") };\n\ng(String::from(\"hello\"))\n\ng(10) // this output error. \n```\n\nRust infer three type of state into the so called anonymous function based on way they make use fo the closure variable\n\n1.) `FnOnce` : This moves the capture variable out of its environment and can only be called once\n\n2.) `FnMut`: This does not moves the capture variable out of its environment, but can mutate it etc.\n\n3.) `Fn`: does not move and does not mutate. can be call more than once\n\nClosure and reference\n\n```rust\nlet v = vec![1,2,3,4];\n\nlet borrow = || {println!(\"list {:?}\", list);\nprintln!(\"Before {:?}\", list);\nborrow();\nprintln!(\"After calling closure: {:?}\", list\n\n```\n\nbut if this gives error. because you can't have mutable reference after immutable reference.\n\n```rust\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    let mut borrows_mutably = || list.push(7);\n    println!(\"After calling closure: {:?}\", list);\n    borrows_mutably();\n    println!(\"After calling closure: {:?}\", list);\n}\n\n```\n\n\n","tags":["rust"]}]