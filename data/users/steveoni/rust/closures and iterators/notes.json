[{"grab":"### closures","views":"Closures genrally mean capturing the variables in outer enviroment into inner enviroment\n\nrust have something similar to annonymous function\n\n```rust\n\nlet g = |x| x;\n\ng(String::from(\"hello\");\n```\n\nit can also takes defined type\n\n```rust\n\nlet g = |x: i32| -> i32 { x}\n\ng(10);\n```\n\nif type is not defined the compiler infer the type from the first call\n\n```rust\nlet g = |x| { println!(\"{x}\") };\n\ng(String::from(\"hello\"))\n\ng(10) // this output error. \n```\n\nRust infer three type of state into the so called anonymous function based on way they make use fo the closure variable\n\n1.) `FnOnce` : This moves the capture variable out of its environment and can only be called once\n\n2.) `FnMut`: This does not moves the capture variable out of its environment, but can mutate it etc.\n\n3.) `Fn`: does not move and does not mutate. can be call more than once\n\nClosure and reference\n\n```rust\nlet v = vec![1,2,3,4];\n\nlet borrow = || {println!(\"list {:?}\", list);\nprintln!(\"Before {:?}\", list);\nborrow();\nprintln!(\"After calling closure: {:?}\", list\n\n```\n\nbut if this gives error. because you can't have mutable reference after immutable reference.\n\n```rust\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    let mut borrows_mutably = || list.push(7);\n    println!(\"After calling closure: {:?}\", list);\n    borrows_mutably();\n    println!(\"After calling closure: {:?}\", list);\n}\n\n```\n\n\n","tags":["rust"]},{"grab":"## function trait","views":"this for example make use of the `FnOnce` trait since it move `list` out of the enviroment\n\n```rust\n use std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n} \n```\n\nand this how to implement custom `FnOnce` using `unwrap_or_else` method for Option Trait\n\n\n```rust\nimpl<T> Option<T> {\n    pub fn unwrap_or_else<F>(self, f: F) -> T\n    where\n        F: FnOnce() -> T\n    {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n\n// the function inside unwrap_or_else can only be called once when None is returned\n```\n\n`sort_by_key` for example make use of `FnMut` base on it default use.\n\n```rust\n #[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!(\"{:#?}\", list);\n} \n```\n but remember the compiler defined the can of trait to use base on our closure variable is used\n\nso this will give us error\n\n```rust\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut sort_operations = vec![];\n    let value = String::from(\"by key called\");\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value);  // moves value ownership into sort_operation and value no longer exist on the next call, ence FnOnce is applied\n        r.width\n    });\n    println!(\"{:#?}\", list);\n\n\n```\n\n ","tags":["rust"]},{"grab":"## Iterators","views":"```rust\n\nlet v1 = vec![1,2,3];\n\nlet v_iter = v.iter();\n\nfor item in v_iter {\n    println!(\"{item}\");\n}\n```\n\nRust have a trait which all iterator object inherit from\n\n```rust\n\npub trait Iterator {\n type Items;\n    fn next(&mut self) -> Option<Self::Item>;\n\n\n//hence\n\nv_iter.next() // 1\nv_iter.next() // 2\n ```\n\nmethod that produce other iterator\n\n```rust\nlet v1: Vec<i32> = vec![1, 2, 3];\n\nlet v2: Vec<_> = v1.iter().map(|x| x+1).collect(); //consume the iterator and collect the result into a collection\n\n```\n\nexample of iterator \n\n```rust\n #[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n} \n```\n \n","tags":["rust"]}]